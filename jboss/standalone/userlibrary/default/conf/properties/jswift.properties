# 
# Si se registra o no un histórico sobre los mensajes SWIFT procesados
# 
# topaz.jswift.saveSwiftMessagesHistory=false

# 
# Si se desea o no tener las tablas utilizadas por jSwift para almacenar los datos de los mensajes (SwiftMessages, MTXXX y SwiftMessagesHistory) en una base diferente a la de Clientes de Topaz
# 
# topaz.jswift.addMessageUserReference=false

# 
# Si se desea o no tener las tablas utilizadas por jSwift para almacenar los datos de los mensajes (SwiftMessages, MTXXX y SwiftMessagesHistory) en una base diferente a la de Clientes de Topaz
# 
# topaz.jswift.database.independent=false

# 
# Nombre de la base de datos de jSwift (si la propiedad topaz.jswift.database.independent es true)
# 
# topaz.jswift.database.base=null

# 
# Si el envío de mensajes SWIFT se efectúa o no en lotes. El envío en lotes consiste en incluir en un mismo archivo todos los mensajes SWIFT a enviar (de otra forma, cada mensaje SWIFT se envía en un archivo diferente)
# 
# topaz.jswift.output.together=?

# 
# Clase que realiza el análisis del resultado del envío de un mensaje
# 
# topaz.jswift.sendResultProcessorImpl=topsystems.jswift.sendResultProcessor.SendResultProcessorImpl

# 
# Clase que realiza la obtención de los datos a incluir en la impresión de los mensajes
# 
# topaz.jswift.outputMessageTransformer=topsystems.jswift.print.OutputMessageToPrinterPagesTransformer

# 
# Si se controla o no la presencia de la secuencia PDM en los bloques 5 de los mensajes SWIFT
# 
# topaz.jswift.input.controlduplicatemessages=false

# 
# Si se controla o no la presencia de la secuencia PDM en los bloques 5 de los mensajes SWIFT
# 
# topaz.jswift.input.controlPDM=false

# 
# Si en la impresión del mensaje SWIFT se muestran o no los datos del mensaje en primer lugar y luego los cabezales y pies
# 
# topaz.jswift.print.msgTextFirst=?

# 
# Si se seleccionan o no los mensajes SWIFT a procesar. En caso afirmativo, es necesario incluir el módulo de validación python
# 
# topaz.jswift.input.selectMessages=?

# 
# Número de estado a utilizar para indicar que un mensaje SWIFT está en estado MESSAGE_TO_SEND
# 
# topaz.jswift.status.message_to_send=?

# 
# Número de estado a utilizar para indicar que un mensaje SWIFT está en estado AUTHORIZED
# 
# topaz.jswift.status.authorized=?

# 
# Número de estado a utilizar para indicar que un mensaje SWIFT está en estado AUTHORIZED_EXTRA_RULES
# 
# topaz.jswift.status.authorized_extra_rules=?

# 
# Número de estado a utilizar para indicar que un mensaje SWIFT está en estado AUTHORIZED
# 
# topaz.jswift.status.message_error_load=?

# 
# Si al emitir un mensaje SWIFT, se quitan o no los caracteres de inicio y fin de archivo del mismo
# 
# topaz.jswift.output.mqsa.keepOutSpecialCharacters=false

# 
# Si al emitir un mensaje SWIFT, se quita o no el agregado de caracteres en blanco hasta alcanzar un tamaño de archivo múltiplo de 512 bytes
# 
# topaz.jswift.output.mqsa.keepOutWhiteSpacesAtEnd=false

# 
# Si se quitan o no los espacios en blanco en los campos de los mensajes SWIFT a emitir
# 
topaz.jswift.output.keepOutWhiteSpaces=true

# Si se ejecuta o no el envio de mensajes Swift a traves de servicios mbean
# Valores:
# - true: se utiliza mbeans
# - false: se envia a traves del mecanismo actual
# Es opcional y por defecto vale "false"
topaz.jswift.output.usembean=true

# 
# Propiedad para cargar la clase que implementa la interfase de RMI de jswift.
# Configurarla con la que este en el canal RMI de JChannelConfig.xml
# 
topaz.jswift.JSwiftRMIServer=topsystems.jswift.rmi.server.JSwiftRMIServerImplText
# 
# Propiedad para cargar la lista de mensajes que tienen que tener obligatoriamente el campo 121 en el bloque 3 con un UETR (UUID valido)
# En el caso de que estemos actuando como intermediarios y el mensaje recibido ya tenia un UETR, este debe ser pasado sin cambios
# En caso contrario, se debe generar un nuevo UETR.
# En la lista debe estar 103+ en vez de 103STP

topaz.jswift.messagesWithMandatoryUETR=103,103+,103REMIT,202,202COV,205,205COV 
