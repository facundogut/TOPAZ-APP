<?xml version="1.0" encoding="UTF-8"?>
<transformation>
  <info>
    <name>GENERICO_CONSTRUIR_CORREO_TEMPLATE</name>
    <description/>
    <extended_description/>
    <trans_version/>
    <trans_type>Normal</trans_type>
    <trans_status>0</trans_status>
    <directory>/</directory>
    <parameters>
      <parameter>
        <name>TEMPLATE</name>
        <default_value>default</default_value>
        <description>Nombre o ruta del template que se utilizará para el envío</description>
      </parameter>
    </parameters>
    <log>
      <trans-log-table>
        <connection/>
        <schema/>
        <table/>
        <size_limit_lines/>
        <interval/>
        <timeout_days/>
        <field>
          <id>ID_BATCH</id>
          <enabled>Y</enabled>
          <name>ID_BATCH</name>
        </field>
        <field>
          <id>CHANNEL_ID</id>
          <enabled>Y</enabled>
          <name>CHANNEL_ID</name>
        </field>
        <field>
          <id>TRANSNAME</id>
          <enabled>Y</enabled>
          <name>TRANSNAME</name>
        </field>
        <field>
          <id>STATUS</id>
          <enabled>Y</enabled>
          <name>STATUS</name>
        </field>
        <field>
          <id>LINES_READ</id>
          <enabled>Y</enabled>
          <name>LINES_READ</name>
          <subject/>
        </field>
        <field>
          <id>LINES_WRITTEN</id>
          <enabled>Y</enabled>
          <name>LINES_WRITTEN</name>
          <subject/>
        </field>
        <field>
          <id>LINES_UPDATED</id>
          <enabled>Y</enabled>
          <name>LINES_UPDATED</name>
          <subject/>
        </field>
        <field>
          <id>LINES_INPUT</id>
          <enabled>Y</enabled>
          <name>LINES_INPUT</name>
          <subject/>
        </field>
        <field>
          <id>LINES_OUTPUT</id>
          <enabled>Y</enabled>
          <name>LINES_OUTPUT</name>
          <subject/>
        </field>
        <field>
          <id>LINES_REJECTED</id>
          <enabled>Y</enabled>
          <name>LINES_REJECTED</name>
          <subject/>
        </field>
        <field>
          <id>ERRORS</id>
          <enabled>Y</enabled>
          <name>ERRORS</name>
        </field>
        <field>
          <id>STARTDATE</id>
          <enabled>Y</enabled>
          <name>STARTDATE</name>
        </field>
        <field>
          <id>ENDDATE</id>
          <enabled>Y</enabled>
          <name>ENDDATE</name>
        </field>
        <field>
          <id>LOGDATE</id>
          <enabled>Y</enabled>
          <name>LOGDATE</name>
        </field>
        <field>
          <id>DEPDATE</id>
          <enabled>Y</enabled>
          <name>DEPDATE</name>
        </field>
        <field>
          <id>REPLAYDATE</id>
          <enabled>Y</enabled>
          <name>REPLAYDATE</name>
        </field>
        <field>
          <id>LOG_FIELD</id>
          <enabled>Y</enabled>
          <name>LOG_FIELD</name>
        </field>
        <field>
          <id>EXECUTING_SERVER</id>
          <enabled>N</enabled>
          <name>EXECUTING_SERVER</name>
        </field>
        <field>
          <id>EXECUTING_USER</id>
          <enabled>N</enabled>
          <name>EXECUTING_USER</name>
        </field>
        <field>
          <id>CLIENT</id>
          <enabled>N</enabled>
          <name>CLIENT</name>
        </field>
      </trans-log-table>
      <perf-log-table>
        <connection/>
        <schema/>
        <table/>
        <interval/>
        <timeout_days/>
        <field>
          <id>ID_BATCH</id>
          <enabled>Y</enabled>
          <name>ID_BATCH</name>
        </field>
        <field>
          <id>SEQ_NR</id>
          <enabled>Y</enabled>
          <name>SEQ_NR</name>
        </field>
        <field>
          <id>LOGDATE</id>
          <enabled>Y</enabled>
          <name>LOGDATE</name>
        </field>
        <field>
          <id>TRANSNAME</id>
          <enabled>Y</enabled>
          <name>TRANSNAME</name>
        </field>
        <field>
          <id>STEPNAME</id>
          <enabled>Y</enabled>
          <name>STEPNAME</name>
        </field>
        <field>
          <id>STEP_COPY</id>
          <enabled>Y</enabled>
          <name>STEP_COPY</name>
        </field>
        <field>
          <id>LINES_READ</id>
          <enabled>Y</enabled>
          <name>LINES_READ</name>
        </field>
        <field>
          <id>LINES_WRITTEN</id>
          <enabled>Y</enabled>
          <name>LINES_WRITTEN</name>
        </field>
        <field>
          <id>LINES_UPDATED</id>
          <enabled>Y</enabled>
          <name>LINES_UPDATED</name>
        </field>
        <field>
          <id>LINES_INPUT</id>
          <enabled>Y</enabled>
          <name>LINES_INPUT</name>
        </field>
        <field>
          <id>LINES_OUTPUT</id>
          <enabled>Y</enabled>
          <name>LINES_OUTPUT</name>
        </field>
        <field>
          <id>LINES_REJECTED</id>
          <enabled>Y</enabled>
          <name>LINES_REJECTED</name>
        </field>
        <field>
          <id>ERRORS</id>
          <enabled>Y</enabled>
          <name>ERRORS</name>
        </field>
        <field>
          <id>INPUT_BUFFER_ROWS</id>
          <enabled>Y</enabled>
          <name>INPUT_BUFFER_ROWS</name>
        </field>
        <field>
          <id>OUTPUT_BUFFER_ROWS</id>
          <enabled>Y</enabled>
          <name>OUTPUT_BUFFER_ROWS</name>
        </field>
      </perf-log-table>
      <channel-log-table>
        <connection/>
        <schema/>
        <table/>
        <timeout_days/>
        <field>
          <id>ID_BATCH</id>
          <enabled>Y</enabled>
          <name>ID_BATCH</name>
        </field>
        <field>
          <id>CHANNEL_ID</id>
          <enabled>Y</enabled>
          <name>CHANNEL_ID</name>
        </field>
        <field>
          <id>LOG_DATE</id>
          <enabled>Y</enabled>
          <name>LOG_DATE</name>
        </field>
        <field>
          <id>LOGGING_OBJECT_TYPE</id>
          <enabled>Y</enabled>
          <name>LOGGING_OBJECT_TYPE</name>
        </field>
        <field>
          <id>OBJECT_NAME</id>
          <enabled>Y</enabled>
          <name>OBJECT_NAME</name>
        </field>
        <field>
          <id>OBJECT_COPY</id>
          <enabled>Y</enabled>
          <name>OBJECT_COPY</name>
        </field>
        <field>
          <id>REPOSITORY_DIRECTORY</id>
          <enabled>Y</enabled>
          <name>REPOSITORY_DIRECTORY</name>
        </field>
        <field>
          <id>FILENAME</id>
          <enabled>Y</enabled>
          <name>FILENAME</name>
        </field>
        <field>
          <id>OBJECT_ID</id>
          <enabled>Y</enabled>
          <name>OBJECT_ID</name>
        </field>
        <field>
          <id>OBJECT_REVISION</id>
          <enabled>Y</enabled>
          <name>OBJECT_REVISION</name>
        </field>
        <field>
          <id>PARENT_CHANNEL_ID</id>
          <enabled>Y</enabled>
          <name>PARENT_CHANNEL_ID</name>
        </field>
        <field>
          <id>ROOT_CHANNEL_ID</id>
          <enabled>Y</enabled>
          <name>ROOT_CHANNEL_ID</name>
        </field>
      </channel-log-table>
      <step-log-table>
        <connection/>
        <schema/>
        <table/>
        <timeout_days/>
        <field>
          <id>ID_BATCH</id>
          <enabled>Y</enabled>
          <name>ID_BATCH</name>
        </field>
        <field>
          <id>CHANNEL_ID</id>
          <enabled>Y</enabled>
          <name>CHANNEL_ID</name>
        </field>
        <field>
          <id>LOG_DATE</id>
          <enabled>Y</enabled>
          <name>LOG_DATE</name>
        </field>
        <field>
          <id>TRANSNAME</id>
          <enabled>Y</enabled>
          <name>TRANSNAME</name>
        </field>
        <field>
          <id>STEPNAME</id>
          <enabled>Y</enabled>
          <name>STEPNAME</name>
        </field>
        <field>
          <id>STEP_COPY</id>
          <enabled>Y</enabled>
          <name>STEP_COPY</name>
        </field>
        <field>
          <id>LINES_READ</id>
          <enabled>Y</enabled>
          <name>LINES_READ</name>
        </field>
        <field>
          <id>LINES_WRITTEN</id>
          <enabled>Y</enabled>
          <name>LINES_WRITTEN</name>
        </field>
        <field>
          <id>LINES_UPDATED</id>
          <enabled>Y</enabled>
          <name>LINES_UPDATED</name>
        </field>
        <field>
          <id>LINES_INPUT</id>
          <enabled>Y</enabled>
          <name>LINES_INPUT</name>
        </field>
        <field>
          <id>LINES_OUTPUT</id>
          <enabled>Y</enabled>
          <name>LINES_OUTPUT</name>
        </field>
        <field>
          <id>LINES_REJECTED</id>
          <enabled>Y</enabled>
          <name>LINES_REJECTED</name>
        </field>
        <field>
          <id>ERRORS</id>
          <enabled>Y</enabled>
          <name>ERRORS</name>
        </field>
        <field>
          <id>LOG_FIELD</id>
          <enabled>N</enabled>
          <name>LOG_FIELD</name>
        </field>
      </step-log-table>
      <metrics-log-table>
        <connection/>
        <schema/>
        <table/>
        <timeout_days/>
        <field>
          <id>ID_BATCH</id>
          <enabled>Y</enabled>
          <name>ID_BATCH</name>
        </field>
        <field>
          <id>CHANNEL_ID</id>
          <enabled>Y</enabled>
          <name>CHANNEL_ID</name>
        </field>
        <field>
          <id>LOG_DATE</id>
          <enabled>Y</enabled>
          <name>LOG_DATE</name>
        </field>
        <field>
          <id>METRICS_DATE</id>
          <enabled>Y</enabled>
          <name>METRICS_DATE</name>
        </field>
        <field>
          <id>METRICS_CODE</id>
          <enabled>Y</enabled>
          <name>METRICS_CODE</name>
        </field>
        <field>
          <id>METRICS_DESCRIPTION</id>
          <enabled>Y</enabled>
          <name>METRICS_DESCRIPTION</name>
        </field>
        <field>
          <id>METRICS_SUBJECT</id>
          <enabled>Y</enabled>
          <name>METRICS_SUBJECT</name>
        </field>
        <field>
          <id>METRICS_TYPE</id>
          <enabled>Y</enabled>
          <name>METRICS_TYPE</name>
        </field>
        <field>
          <id>METRICS_VALUE</id>
          <enabled>Y</enabled>
          <name>METRICS_VALUE</name>
        </field>
      </metrics-log-table>
    </log>
    <maxdate>
      <connection/>
      <table/>
      <field/>
      <offset>0.0</offset>
      <maxdiff>0.0</maxdiff>
    </maxdate>
    <size_rowset>100</size_rowset>
    <sleep_time_empty>50</sleep_time_empty>
    <sleep_time_full>50</sleep_time_full>
    <unique_connections>N</unique_connections>
    <feedback_shown>Y</feedback_shown>
    <feedback_size>50000</feedback_size>
    <using_thread_priorities>Y</using_thread_priorities>
    <shared_objects_file/>
    <capture_step_performance>N</capture_step_performance>
    <step_performance_capturing_delay>1000</step_performance_capturing_delay>
    <step_performance_capturing_size_limit>100</step_performance_capturing_size_limit>
    <dependencies>
    </dependencies>
    <partitionschemas>
    </partitionschemas>
    <slaveservers>
    </slaveservers>
    <clusterschemas>
    </clusterschemas>
    <created_user>-</created_user>
    <created_date>2024/01/17 15:24:45.773</created_date>
    <modified_user>-</modified_user>
    <modified_date>2024/01/17 15:24:45.773</modified_date>
    <key_for_session_key>H4sIAAAAAAAAAAMAAAAAAAAAAAA=</key_for_session_key>
    <is_key_private>N</is_key_private>
  </info>
  <notepads>
  </notepads>
  <order>
    <hop>
      <from>Obtiene set de datos</from>
      <to>Marca última fila del set de datos</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Obtiene set de datos</from>
      <to>No se recibieron filas?</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Marca última fila del set de datos</from>
      <to>Construye cuerpo del correo</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>No se recibieron filas?</from>
      <to>No Filas</to>
      <enabled>Y</enabled>
    </hop>
    <hop>
      <from>Construye cuerpo del correo</from>
      <to>Settea variable CUERPO con contenido parseado</to>
      <enabled>Y</enabled>
    </hop>
  </order>
  <step>
    <name>Construye cuerpo del correo</name>
    <type>ScriptValueMod</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <compatible>N</compatible>
    <optimizationLevel>9</optimizationLevel>
    <jsScripts>
      <jsScript>
        <jsScript_type>0</jsScript_type>
        <jsScript_name>Transforma</jsScript_name>
        <jsScript_script>// Marca que la fila se procesará.
trans_Status = CONTINUE_TRANSFORMATION;

// Si falta algun campo crítico, aborta el step.
if (PRIMERA == true)
	validarCamposRequeridos();

// Validamos el Template
if (ERROR == false &amp;&amp; PRIMERA == true)
	validarInterpolates();

// Si falta algun campo mencionado en el template, aborta el step.
if (ERROR == false &amp;&amp; PRIMERA == true)
	validarTokensExisten();

if (ERROR == false)
{
	// Acumula set de datos
	dataset.push(row);
	
	// Si no es la ultima fila, la saltea. (ya tengo la información de la misma en el set)
	if (ULTIMA_FILA == false) {
		trans_Status = SKIP_TRANSFORMATION;
	}
	
	// Sino, hace la magia.
	else {
		// Si no hay errores, ejecuta la interpolación.
		if (ERROR == false) {
			TEMPLATE_PARSEADO = interpolarTemplate();
		}
	}
}
</jsScript_script>
      </jsScript>
      <jsScript>
        <jsScript_type>1</jsScript_type>
        <jsScript_name>Inicio</jsScript_name>
        <jsScript_script>var ERROR = false;
var PRIMERA = true;

// -----Construye ruta de lectura del Template------------------

const rutaLectura = String(getVariable("Top.Param", "") + "EMAIL_TEMPLATES/");

const TEMPLATE = String(getVariable("TEMPLATE", ""));

if (TEMPLATE == "default")
	abortar("No se recibio parametro obligatorio TEMPLATE");

const rutaArchivo = rutaLectura + TEMPLATE;

if (fileExists(rutaArchivo) == true) {
  const contenidoTemplate = String(loadFileContent(rutaArchivo, 'UTF-8'));
} else {
  abortar("No se encontró el archivo de template (plantilla). Ruta leida: " + rutaArchivo);
}

// -----Definición de Constantes y variables--------------------

// Campos que se necesitan para poder ejecutar la interpolación.

const CAMPO_ID = "INTERPOLATE_ID";
const CAMPOS_REQUERIDOS = [CAMPO_ID];

// Patron para encontrar bloques de &lt;interpolate id="ID_ENVIADO">Contenido&lt;/interpolate>
//
// match[0] tiene el bloque que causo el match
// match[1] tiene el valor de id
// match[2] tiene el contenido del bloque
const PATRON_INTERPOLACION = /&lt;interpolate[ ]+id[ ]*=[ ]*"([^"]*)"[ ]*>([\s\S]*?)&lt;\/interpolate>/g

// Patron para encontrar bloques de {{CAMPO}}  
//
// match[0] tiene el bloque que causo el match
// match[1] tiene el nombre de la variable mencionada
const PATRON_TOKEN = /\{\{([^}]+)\}\}/g

// Patron para encontrar bloques de &lt;interpolate y extraer el resto de la linea.
// Uso unicamente para validación
//
// match[0] tiene la linea que llamo al interpolate
// match[1] tiene el resto de la linea
const PATRON_INTERPOLATE_LLAMADA = /&lt;interpolate([^>]*>)/g

// Patron para validar argumentos de 
const PATRON_INTERPOLATE_ARGUMENTOS = /^[ ]+id[ ]*=[ ]*"[^"]*"[ ]*>[ ]*$/

// Arreglo que se carga en el script de transformación con las filas recibidas.
var dataset = [];

// Variable que contendrá el cuerpo del correo
var TEMPLATE_PARSEADO = "";

// -----Funciones-----------------------------------------------

//Funcion que setea variables de error y aborta
function abortar (MSG)
{
	writeToLog("e", "***Constructor Template Correos***");
	writeToLog("e", "Error: " + MSG);
	setVariable("RESULTADO", MSG, "r");
	ERROR = true;
	trans_Status = ERROR_TRANSFORMATION;
}

// Devuelve un arreglo de strings conteniendo todos los nombres de los campos
// en la fila.
function obtenerCamposEntrada() {
	
	// Obtiene campos con tipo de dato String de java
	var fieldNamesJava = getInputRowMeta().getFieldNames();
	
	// Arreglo conteniendo los nombres de los campos en String de javascript.
	var fieldNames = [];
	
	// Parsea cada campo a String de javascript
	for (var i = 0; i &lt; fieldNamesJava.length; i++) {
		fieldNames.push(String(fieldNamesJava[i]));
	}
  
	return fieldNames;

}

// Funcion que maneja los distintos tipos de datos de Pentaho y
// aplica un formateo predefinido por tipo de datos.
// Se utiliza por motivos de compatibilidad, pero se recomienda
// siempre informar los campos como String desde el lado del
// consumidor del 
function parsearCampo(valorMetadatos, valor) {

	var tipoDato = valorMetadatos.getType();

	switch(tipoDato) {
		case valorMetadatos.TYPE_INTEGER: return num2str(valor, "#");
		case valorMetadatos.TYPE_NUMBER: return num2str(valor, "0.00");
		case valorMetadatos.TYPE_BIGNUMBER: return num2str(valor, "0.00");
		case valorMetadatos.TYPE_DATE: 
			try { 
				return date2str(valor, "dd/MM/yyyy HH:mm:ss");
			} catch (ex) { 
				writeToLog("e", "Error casteando valor: " + valor);
				return null;
			}
		case valorMetadatos.TYPE_BOOLEAN: return (valor == true) ? 'SI' : 'NO';
		case valorMetadatos.TYPE_BINARY: return valorMetadatos.getString(valor);
		default: return valorMetadatos.getString(valor);
	}

}


// Retorna una lista con todos los nombres de los tokens encontrados en el 
// template
function obtenerTokensTemplate() {
	
	var listaTokens = [];
	var matches = [];

	while ((matches = PATRON_TOKEN.exec(contenidoTemplate)) !== null) {
		
		var variableToken = String(matches[1]);
		
		//if (listaTokens.indexOf(variableToken) === -1)
			listaTokens.push(variableToken);
		
	}
	
	return listaTokens;
	
}


// Validar que los campos requeridos para el proceso se encuentran en las filas
// recibidas.
function validarCamposRequeridos() {
  var camposEntrada = obtenerCamposEntrada();
  
  // Recorro los campos requeridos, si alguno no se encuentra en la fila, aborta.
  for (var i = 0; i &lt; CAMPOS_REQUERIDOS.length; i++) {
    if (camposEntrada.indexOf(CAMPOS_REQUERIDOS[i]) === -1) {
      abortar("Falta el campo obligatorio: " + CAMPOS_REQUERIDOS[i]);
      return false;
    }
  }
  
  return true;
}


// Valida que los tokens que se encuentran en el template se corresponden
// con los campos recibidos.
// Puedo recibir campos de más, pero no de menos.
function validarTokensExisten() {

  var camposEntrada = obtenerCamposEntrada();
  var tokensEncontrados = obtenerTokensTemplate();
  
  // Recorre los tokens encontrados
	for(var i = 0; i &lt; tokensEncontrados.length; i++) {
    
    // Si no encuentra uno de los campos requeridos en los campos recibidos, aborta
		if (camposEntrada.indexOf(tokensEncontrados[i]) === -1) {
			abortar("Falta el campo: " + tokensEncontrados[i]);
			return false;
		}
  }
	
	return true;
  
}


// Itera por el template buscando las ocurrencias de &lt;interpolate>
// Si encuentra una, guarda su ID en el arreglo
// Si se encuentra más de un bloque &lt;interpolate> con el mismo ID, aborta.
function validarInterpolates() {
  
  // Guarda los ID encontrados
  var idEncontrados = [];
  var matches = [];
  
  // Busca ocurrencias de &lt;interpolate id="ID">
  while((matches = PATRON_INTERPOLATE_LLAMADA.exec(contenidoTemplate)) !== null) {
    
    // Contiene el resto de la linea que llamo a un interpolate
    var argumentos = matches[1];

	var argumentosTrimmed = trim(argumentos)
    
	// Si no tiene argumentos, es invalido
	if (argumentos == null || argumentosTrimmed == "") {
		abortar("Template inválido. Existen bloques de &lt;interpolate> sin argumento id");
		return false;
	}
	
	// Si no tiene el caracter ">" al final, es invalido
	if (argumentosTrimmed.slice(-1) != ">") {
		abortar("Template inválido. Existen bloques de &lt;interpolate&gt; no cerrados");
		return false;
	}
	
	// Si no matchea con el patrón, tiene algo raro
	if (argumentos.match(PATRON_INTERPOLATE_ARGUMENTOS) == null) {
		abortar('Template inválido. Existen bloques de &lt;interpolate> con argumentos inesperados');
		return false;
	}
    
  }
  
  return true;
}


// Función Principal.
//
// Busca cada ocurrencia de bloques &lt;interpolate id="ID">.
// Cuando encuentra uno, busca las filas que tengan el mismo ID.
// Por cada ocurrencia del token {{variable}}, reemplaza con los valores de los campos para esas filas.
// Retorna el template con el bloque &lt;interpolate> repetido por la cantidad de filas que encontró
function interpolarTemplate() {
	
	var interpolateMatches = [];
	var tokenMatches = [];
	
  // Variable conteniendo el template final.
  // Se inicializa con el contenido original para realizar los reemplazos iterativamente.
	var templateParseado = contenidoTemplate;

	// Bucle para analizar ocurrencia de &lt;interpolate>&lt;/interpolate>
	while ((interpolateMatches = PATRON_INTERPOLACION.exec(contenidoTemplate)) !=	null) {

		var llamada = interpolateMatches[0];
		var id = interpolateMatches[1];
		var contenido = interpolateMatches[2];
			
		if (id == null ) continue;
		
		// Necesito el contenido original del bloque y una variable para construir
		// la interpolación.
		var contenidoParseado = "";

		// Obtengo todas las filas para el id solicitado
		var datasetFiltrado = obtenerFilasPorId(id);

		// Para cada fila recibida tengo que replicar el contenido con interpolacion.
		for (var i = 0; i &lt; datasetFiltrado.length; i++) {
			
			var fila = datasetFiltrado[i];
			
			var contenidoTemporal = contenido;
		
			// Busco todas las ocurrencias de llamadas a un token en el template.
			while((tokenMatches = PATRON_TOKEN.exec(contenido)) !== null) {
				
				// Llamada ejecutada
				var llamadaToken = String(tokenMatches[0]);
				
				// Obtiene el nombre de la variable llamada
				var variableToken = String(tokenMatches[1]);
				
				// Obtiene el indice del campo que llama la variable
				var indiceToken = getInputRowMeta().indexOfValue(variableToken);
				
				// Si el indice no fue encontrado aborta el proceso
				if (indiceToken == -1) trans_Status = ERROR_TRANSFORMATION;

				// Obtiene el valor que tiene la fila para ese campo y lo castea a String
				var valorToken = parsearCampo(getInputRowMeta().getValueMeta(indiceToken), fila[indiceToken]);

				// Si el valor recibido es nulo, remplaza con string vacío
				if (valorToken == null) valorToken = "";
				
				// Construye la llamada original
				//var llamadaToken = "{{" + variableToken + "}}";
				
				// Reemplaza la llamada original por la llamada obtenida
				contenidoTemporal = contenidoTemporal.replace(llamadaToken, valorToken);

			}
			
			// Agrego los reemplazos realizados por la fila al reemplazo total
			contenidoParseado += contenidoTemporal; 
			
		}

		// Reemplazo la llamada del bloque &lt;interpolate> por el contenido parseado
		templateParseado = templateParseado.replace(llamada, contenidoParseado);
		
	}

	return templateParseado;

}

// Permite filtrar las filas que corresponden al ID de interpolate
// necesario.
function obtenerFilasPorId(id) {
	
	var nuevoDataset = [];
	var indiceId = getInputRowMeta().indexOfValue(CAMPO_ID);
  
	// Cada iteración contiene una fila.
	for(var i = 0; i &lt; dataset.length; i++) {
		
		var fila = dataset[i];		
		var valorId = fila[indiceId];
    // Si es la fila tiene el id solicitado
		if (valorId == id) {
      // Agrega la fila al dataset filtrado
			nuevoDataset.push(fila);
		}
	}
	
	if (nuevoDataset.length == 0) {
		abortar("No se encontraron filas para el id: " + id);
	}	

	return nuevoDataset;
	
}</jsScript_script>
      </jsScript>
    </jsScripts>
    <fields>
      <field>
        <name>TEMPLATE_PARSEADO</name>
        <rename>TEMPLATE_PARSEADO</rename>
        <type>String</type>
        <length>-1</length>
        <precision>-1</precision>
        <replace>N</replace>
      </field>
    </fields>
    <attributes/>
    <cluster_schema/>
    <remotesteps>
      <input>
      </input>
      <output>
      </output>
    </remotesteps>
    <GUI>
      <xloc>672</xloc>
      <yloc>208</yloc>
      <draw>Y</draw>
    </GUI>
  </step>
  <step>
    <name>Marca última fila del set de datos</name>
    <type>DetectLastRow</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <resultfieldname>ULTIMA_FILA</resultfieldname>
    <attributes/>
    <cluster_schema/>
    <remotesteps>
      <input>
      </input>
      <output>
      </output>
    </remotesteps>
    <GUI>
      <xloc>432</xloc>
      <yloc>208</yloc>
      <draw>Y</draw>
    </GUI>
  </step>
  <step>
    <name>No Filas</name>
    <type>ScriptValueMod</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <compatible>N</compatible>
    <optimizationLevel>9</optimizationLevel>
    <jsScripts>
      <jsScript>
        <jsScript_type>0</jsScript_type>
        <jsScript_name>Script 1</jsScript_name>
        <jsScript_script>trans_Status = CONTINUE_TRANSFORMATION; //Estado default (Permite arrojar error por el javascript)

abortar('NO se puede aplicar el Template ya que NO se recibieron filas con datos'); 
</jsScript_script>
      </jsScript>
      <jsScript>
        <jsScript_type>1</jsScript_type>
        <jsScript_name>Item_0</jsScript_name>
        <jsScript_script>//Funcion que setea variables de error y aborta
function abortar (MSG)
{
	writeToLog("e", "***Constructor Template Correos***");
	writeToLog("e", "Error: " + MSG);
	setVariable("RESULTADO", MSG, "r");
	trans_Status = ERROR_TRANSFORMATION;
}
</jsScript_script>
      </jsScript>
    </jsScripts>
    <fields>    </fields>
    <attributes/>
    <cluster_schema/>
    <remotesteps>
      <input>
      </input>
      <output>
      </output>
    </remotesteps>
    <GUI>
      <xloc>192</xloc>
      <yloc>432</yloc>
      <draw>Y</draw>
    </GUI>
  </step>
  <step>
    <name>No se recibieron filas?</name>
    <type>DetectEmptyStream</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <attributes/>
    <cluster_schema/>
    <remotesteps>
      <input>
      </input>
      <output>
      </output>
    </remotesteps>
    <GUI>
      <xloc>192</xloc>
      <yloc>336</yloc>
      <draw>Y</draw>
    </GUI>
  </step>
  <step>
    <name>Obtiene set de datos</name>
    <type>RowsFromResult</type>
    <description/>
    <distribute>N</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <fields>      </fields>
    <attributes/>
    <cluster_schema/>
    <remotesteps>
      <input>
      </input>
      <output>
      </output>
    </remotesteps>
    <GUI>
      <xloc>192</xloc>
      <yloc>208</yloc>
      <draw>Y</draw>
    </GUI>
  </step>
  <step>
    <name>Settea variable CUERPO con contenido parseado</name>
    <type>SetVariable</type>
    <description/>
    <distribute>Y</distribute>
    <custom_distribution/>
    <copies>1</copies>
    <partitioning>
      <method>none</method>
      <schema_name/>
    </partitioning>
    <fields>
      <field>
        <field_name>TEMPLATE_PARSEADO</field_name>
        <variable_name>CUERPO</variable_name>
        <variable_type>ROOT_JOB</variable_type>
        <default_value/>
      </field>
    </fields>
    <use_formatting>Y</use_formatting>
    <attributes/>
    <cluster_schema/>
    <remotesteps>
      <input>
      </input>
      <output>
      </output>
    </remotesteps>
    <GUI>
      <xloc>928</xloc>
      <yloc>208</yloc>
      <draw>Y</draw>
    </GUI>
  </step>
  <step_error_handling>
  </step_error_handling>
  <slave-step-copy-partition-distribution>
  </slave-step-copy-partition-distribution>
  <slave_transformation>N</slave_transformation>
  <attributes/>
</transformation>
